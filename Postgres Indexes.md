# Андрей Сальников — Индексы в PostgreSQL. Как понять, что создавать
https://youtu.be/ju9F8OvnL4E?si=49VWlAV0PrMY_Osj

## Минусы индексов:
* Замедление записи в таблицы (реляционки подходят для OLTP Нагрузки 80% чтения, 20% записи)
* Могут занимать внушительные объемы на диске. Если сумма размеров всех индексов до 50% размера таблицы - все ок, если нет - чето идет не так 
* Усложненное техническое обслуживание - индексы пухнут и вакуум на них не так хорошо работает. Особенно на часто изменяемых данных
* Индекс может сделать хуже

## Чеклист создания индекса:
- Ориентироваться только на прод
- Обладать статистикой нагрузки на БД от запросов ( долгий запрос не всегда плохой запрос. Плохой запрос может быть быстрым, но частым и не оптимизированным)
  * pg_stat_statements - хорошо
  * pgBadger - с осторожностью (парсер логов постгреса) - проблема может быть в том, что не все запросы логируются (супербыстрые могут не логироваться)
- Иметь примеры запросов с параметрами
  * для понимания входящих параметров запроса
  * необходимо для проверки
- Уметь читать статистику распределения данных (планировщик). Есть планировщик и екзекутор. Планировщик строит свой выбор на статистике
- Представление pg_stats.
    Важные колонки:
  * уникальность значений в колонке n_distinct
  * упорядоченность значений: сorrelation
  * объемы null: null_frac
  * Частые значения: most_common_vals и most_common_freqs
- Вручную собрать более полную статистику (в постгресе берется sample в 30k строк (можно менять для всего инстанса или конкретной таблицы)). Юзать если есть ощущения что  в статистике есть существенные промахи

## Типы индексов

* **btree** - наиболее старый тип индексов и самый распространенный
  * Наиболее распространенный тип индексов
  * алгоритмы работы и модель хранения улучшаются
  * покрывает 90% задач
  * Легко создать ориентируясь на статистику по таблице
* **hash** 
  * бесполезен, btree работает быстрее в общих случаях
  * сделан потому что Hash занимает меньше места чем btree индекс, раньше было ограничение
  * обслуживает только операцию равенства, когда btree может обслуживать операцию сравнения и равенства
* **gist** - позволяет решать задачи типа Расстояние, площадь, перекрытие 
  * в чистом виде полезен для геоданных
  * есть расширения
    * pg_trgm - позволяет индексировать запросы по подстроке like, ilike, ~ ,~* (regexp)
    * btree_gist - сложные constraints с интервалами (задача создания расписаний, чтобы расписания не пересекались)
* **sp_gist** 
  * практических применений в oltp нет
* **gin**
  * не сильно радует dba (может просадить диск буффером), могут быть долгие коммиты
  * хорош для текстового поиска (+ pg_tgrm )
  * нужен для поиска по jsonb. Есть два оператора 
    * jsonb_ops - индексирует все что есть в json и по нему можно искать любое значение в json. Может быть просто огромным
    * jsonb_path_ops - заточен на поиск путей в жсон, размер меньше 
* **brin** - когда данных много и они упорядоченны движки бд почти всегда достают данные блоками. 
Мы можем проиндексировать только наименьшее и наибольшее значение блока
  * Крайне компактный индекс
  * Работает быстро
  * Но мы не всегда уверенны, что значение есть в блоке (его может просто не быть в бд вообще)

## Indexes null or not null















































