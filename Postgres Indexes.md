# Андрей Сальников — Индексы в PostgreSQL. Как понять, что создавать
https://youtu.be/ju9F8OvnL4E?si=49VWlAV0PrMY_Osj

## Минусы индексов:
* Замедление записи в таблицы (реляционки подходят для OLTP Нагрузки 80% чтения, 20% записи)
* Могут занимать внушительные объемы на диске. Если сумма размеров всех индексов до 50% размера таблицы - все ок, если нет - чето идет не так 
* Усложненное техническое обслуживание - индексы пухнут и вакуум на них не так хорошо работает. Особенно на часто изменяемых данных
* Индекс может сделать хуже

## Чеклист создания индекса:
- Ориентироваться только на прод
- Обладать статистикой нагрузки на БД от запросов ( долгий запрос не всегда плохой запрос. Плохой запрос может быть быстрым, но частым и не оптимизированным)
  * pg_stat_statements - хорошо
  * pgBadger - с осторожностью (парсер логов постгреса) - проблема может быть в том, что не все запросы логируются (супербыстрые могут не логироваться)
- Иметь примеры запросов с параметрами
  * для понимания входящих параметров запроса
  * необходимо для проверки
- Уметь читать статистику распределения данных (планировщик). Есть планировщик и екзекутор. Планировщик строит свой выбор на статистике
- Представление pg_stats.
    Важные колонки:
  * уникальность значений в колонке n_distinct
  * упорядоченность значений: сorrelation
  * объемы null: null_frac
  * Частые значения: most_common_vals и most_common_freqs
- Вручную собрать более полную статистику (в постгресе берется sample в 30k строк (можно менять для всего инстанса или конкретной таблицы)). Юзать если есть ощущения что  в статистике есть существенные промахи

## Типы индексов

* **btree** - наиболее старый тип индексов и самый распространенный
  * Наиболее распространенный тип индексов
  * алгоритмы работы и модель хранения улучшаются
  * покрывает 90% задач
  * Легко создать ориентируясь на статистику по таблице
* **hash** 
  * бесполезен, btree работает быстрее в общих случаях
  * сделан потому что Hash занимает меньше места чем btree индекс, раньше было ограничение
  * обслуживает только операцию равенства, когда btree может обслуживать операцию сравнения и равенства
* **gist** - позволяет решать задачи типа Расстояние, площадь, перекрытие 
  * в чистом виде полезен для геоданных
  * есть расширения
    * pg_trgm - позволяет индексировать запросы по подстроке like, ilike, ~ ,~* (regexp)
    * btree_gist - сложные constraints с интервалами (задача создания расписаний, чтобы расписания не пересекались)
* **sp_gist** 
  * практических применений в oltp нет
* **gin**
  * не сильно радует dba (может просадить диск буффером), могут быть долгие коммиты
  * хорош для текстового поиска (+ pg_tgrm )
  * нужен для поиска по jsonb. Есть два оператора 
    * jsonb_ops - индексирует все что есть в json и по нему можно искать любое значение в json. Может быть просто огромным
    * jsonb_path_ops - заточен на поиск путей в жсон, размер меньше 
* **brin** - когда данных много и они упорядоченны движки бд почти всегда достают данные блоками. 
Мы можем проиндексировать только наименьшее и наибольшее значение блока
  * Крайне компактный индекс
  * Работает быстро
  * Но мы не всегда уверенны, что значение есть в блоке (его может просто не быть в бд вообще)

## Indexes null or not null

Пререквизиты:
таблица public.pgconf, rows count 10_000_000

| Column      | TYPE                    | Collation | Nullable | Default |
| ----------- |-------------------------|-----------|----------|---------|
| id          | bigint                  |           | Not null |         |
| fk_id       | bigint                  |           |          |         |
| state       | text                    |           |          |         |
| amount      | numeric                 |           |          |         |
| item        | text                    |           |          |         |
| created_at  | timestamp with timezone |           |          |         |

Indexes: 
  pgconf_pkey PRIMARY KEY, btree(id)

FK constraints:
  pgconf_fk_id_fkey FOREIGN KEY (fk_id) REFERENCES pgconf(id)

Size pgconf 816 MB.
Size pgconf_pkey 214 MB 


Удалим строку:\
`delete from pgconf where id = 10;`

_Delete on pgconf\
-> Index Scan using pgconf_pkey on pgconf\
Index Cond: (id = 10)\
Planning Time: 0.043 ms\
**Trigger for constraint pgconf_fk_id_fkey: time=690.455 calls=1**\
Execution Time: **690.515 ms**_

Самое долгое время занимает поиск по constraint. Даже с двумя worker очень долго. 
Запрос не долгий, небольшой, может непопасть в логи, и очень неоптимальный.

Под капотом будет:

`select * from pgconf where fk_id = 10;`\
Gather\
Workers Planned: 2\
Workers Launched: 2\
-> **Parallel Seq Scan on pgconf**\
Filter: (fk_id = 10)\
Rows Removed by Filter: 3333333\
Planning Time: 0.059 ms\
Execution Time: 281.468 ms\

Для FK лучше создавать индекс, чтобы всякие проверки работали быстро.
Работать станет быстрее. Но можно пойти дальше -> зайдем в табличку pg_stats

select * from pg_stats where tablename = 'pgconf' and attname = 'fk_id';\

|                   |                | 
|-------------------|----------------| 
| tablename         | pgconf         | 
| attname           | fk_id          | 
| null_frac         | **0.92943335** |  
| n_distinct        | -0.070566654   | 
| most_common_vals  | null           | 
| most_common_freqs | null           | 
| correlation       | 0.0095442245   | 

Почти 93 процента пустых значений. Остальные поля по данным не важны при таком кол-ве нуллов.
Попробуем улучшить индекс, добавим условие nonnull. Сделаем частичный индекс.
` create index fk_not_null on pgconf (fk_id) where fk_id is not null; `\
Не ускорит запрос, но существенно сохранит место на диске 

Но этот индекс будет прекрасно работать на запросе по равенству или неравенству (PG сам поймет, что мы ищем non null значения).
В общем случае данный индекс будет применяться, когда в запросе есть условие аналогичное или приводимое к условию частичного индекса.

`select * from pgconf where fk_id = 10;`
**Index Scan using fk_not_null** on pgconf
Index Cond: (fk_id = 10)
Planning Time: 0.080 ms
Execution Time: 0.027 ms
 
 ### Результаты 
Time: 690.713 ms vs 0.336 ms
**Ускорение в 2055 раз!**
pgconf_pkey : 214 MB
fk : 215 MB
fk_not_null : 15 MB
**Уменьшение размеров в 14 раз!**


## Indexes partial







































